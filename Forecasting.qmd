---
title: "Mô hình ARIMA"
subtitle: "Việt Nam, 2024"
categories: ["SupplyChainManagement", "Forecasting"]
bibliography: references.bib
---

# Thực hành trong Rstudio:

Bạn có thể quay lại trang đầu tiên để lấy dữ liệu gốc và các bước để chỉnh sửa dữ liệu ở [Giới thiệu](index.qmd).

```{r}
#| warning: false
#| message: false
#| echo: false
#Call packages:
pacman::p_load(rio,
               here,
               janitor,
               tidyverse,
               dplyr,
               magrittr,
               lubridate,
               stringr
               )

#Import file:
product_demand<-import("C:\\Users\\locca\\Downloads\\Historical Product Demand.csv")

#Change to suitable class (I change the name dataset to product_demand to shortly write)
product_demand <-product_demand %>% 
    mutate(Date = as.Date(Date,format = "%Y/%m/%d"),
           Product_Category = as.factor(Product_Category))

product_demand$Order_Demand <- 
  gsub("[(]", "-", product_demand$Order_Demand)
product_demand$Order_Demand <- 
  gsub("[)]", "", product_demand$Order_Demand)
product_demand$Order_Demand <- 
  as.numeric(product_demand$Order_Demand)

#Then I will create a lot of cols contain year, month, week data and just select from 2012 to 2016:
product_demand <-product_demand %>%
  mutate(Month = month(Date),
         Year = year(Date),
         Week_day = wday(Date)) %>% 
  filter(Year %in% c(2016:2012))


#So I will calculate the total order demand divided by year and month:
month_df<-product_demand %>% 
  group_by(Year,Month) %>%   
  summarise(month_demand = round(sum(Order_Demand,
                               na.rm = T)/10^6,3)) %>% 
  mutate(datetime = as.Date(str_c(Year,
                                    Month,
                                    "1",
                                    sep = "-"))) %>% 
  ungroup() %>% 
  select(-c(Year,Month))
```

Sau khi đã chuyển đổi dữ liệu, tiếp theo chúng ta sẽ chia dữ liệu theo tỉ lệ 70:30. Lý do chia ra là vì ở phần cuối, chúng ta sẽ sử dụng phần 30% bộ dữ liệu để đánh giá mô hình được xây dựng trên 70% bộ dữ liệu.

Việc chia dữ liệu này cũng khá phổ biến vì ta có thể đánh giá mô hình bằng chính dữ liệu thực tế và không cần tốn thời gian và công sức để theo dõi mô hình trong tương lai nữa.

```{r}
#| warning: false
#| message: false
#First we will divde the data into training data and testing data in 70-30:
#Create ts object for month demand variable:
training_df<-month_df[month_df$datetime <= as.Date("2015-03-01"),]
testing_df <-month_df[month_df$datetime >= as.Date("2015-03-01"),]
```

Nhìn hình dưới đây, các bạn có thể hiểu là nhiệm vụ của mình sẽ là xây dựng mô hình dựa vào dữ liệu đã thu được trước ngày `01-03-2015` và dự đoán giá trị cho khoảng thời gian từ `01-03-2015` đến `01-12-2016`.

```{r}
#| warning: false
#| message: false
demand_training<-ts(training_df$month_demand,
                      frequency = 12,
                      start = c(2012,1))
demand_testing<-ts(testing_df$month_demand,
                frequency = 12,
                start = c(2015,3))

## Hiển thị hóa dữ liệu về demand:
library(dygraphs)
lines<-cbind(demand_training,
             demand_testing)
dygraph(lines,
        main = "Training and testing data", 
        ylab = "Quantity order (Unit: Millions)") %>% 
  dySeries("demand_training", label = "Training data") %>%
  dySeries("demand_testing", label = "Testing data") %>%
  dyOptions(fillGraph = TRUE, fillAlpha = 0.4) %>% 
  dyRangeSelector(height = 20)
```

## Phân tích thành phần trong time-series dữ liệu:

Về thông tin của dữ liệu, đây là dữ liệu thuộc dạng time-series nghĩa là chuỗi dữ liệu theo thời gian nên nó sẽ có các đặt tính chung như:

-   Trend: Tăng, giảm dài hạn hoặc chuyển động đứng yên.

-   Seasonal: Các mô hình có thể dự đoán được ở những khoảng thời gian cố định.

-   Cycle: Biến động không có chu kỳ nhất quán.

-   Noise: Sai số còn sót lại không giải thích được.

Vậy mục tiêu của việc phân tích time series là để tìm ra thành phần *seasonal* trong vì nó có tính lặp lại và có thể dùng để dự đoán cho tương lai. Ngoài ra, thành phần *trend* cũng cần được quan tâm vì nó thể hiện xu hướng của dữ liệu trong tương lai.

Trong R, ta có thể phân tích dễ dàng với hàm `decompose()` như code dưới đây.

Về công thức tính, hàm `decompose()` dựa vào kĩ thuật Moving Averages để tính trung bình giá trị theo 1 khoảng thời gian (Vd: 3 tháng 6 tháng hoặc 1 năm).

![Hình 3: Additive and multiplicative model](img/decompose.png){fig-alt="(Nguồn: R documentation)" fig-align="center" width="609"}

Có 2 mô hình gồm *Additive* và *Multiplicative* có thể sử dụng. Ở mặc định, hàm `decompose()` tính theo mô hình *Additive*, còn bạn muốn tính theo mô hình *Multiplicative* thì phải thêm đối số `type = "multiplicative"`.

```{r}
#| warning: false
#| message: false
#| fig-cap: "Khi mức độ biến động của seasonal hoặc sự biến đổi xung quanh trend-cycle không thay đổi theo mức độ của chuỗi thời gian, mô hình Additive sẽ phù hợp hơn mô hình Multiplicative."

library(TSstudio)
ts_decompose(demand_training, 
             type = "both")
```

Nhìn sơ bộ, ta có thể thấy xu hướng tăng (trend) của số lượng đơn đặt hàng. Về phần random thì sẽ có 1 khoảng từ (-10,5) số đơn là tự nhiên xảy ra, nghĩa là giá trị dự đoán có thể lệch từ -10 đến 5 đơn hàng và sai lệch này là do tự nhiên.

## Dự đoán bằng mô hình ARIMA:

Trên thực tế, phần phân tích thành các thành phần của time series chỉ đưa ra dự đoán định tính, không thể dự đoán bằng các dữ liệu trên mà phải cần thông qua mô hình cụ thể. Dưới đây là giới thiệu về mô hình ARIMA.

### Định nghĩa về ARIMA:

Theo [@phamdinhkhanh2019], Mô hình ARIMA "sử dụng đầu vào chính là những tín hiệu quá khứ của chuỗi được dự báo để dự báo nó. Các tín hiệu đó bao gồm: Chuỗi tự hồi qui AR (auto regression) và chuỗi trung bình trượt MA (moving average).

Hầu hết các chuỗi thời gian sẽ có xu hướng tăng hoặc giảm theo thời gian, do đó yếu tố chuỗi dừng thường không đạt được. Trong trường hợp chuỗi không dừng thì ta sẽ cần biến đổi sang chuỗi dừng bằng sai phân. Khi đó tham số đặc trưng của mô hình sẽ có thêm thành phần bậc của sai phân d và mô hình được đặc tả bởi 3 tham số ARIMA(p, d, q)".

Mô hình được xây dựng "dựa trên giả thuyết: *Stationary series* (Chuỗi dừng) đòi hỏi *Phương sai sai số không đổi* và Nhiễu trắng (*White noise*), cụ thể trong đó:

-   Stationary series: điều kiện là trung bình của chuỗi là constant (bất biến), phương sai (variance) của chuỗi phải có tính đồng nhất (homoscedasticity) và hiệp phương sai (covariance) giữa giá trị t và t+1 phải không liên quan tới nhau.

    ::: {.callout-warning appearance="minimal"}
    ## Lưu ý

    Nếu chuỗi dữ liệu không phải là chuỗi dùng thì bạn sẽ không xây dựng được mô hình chuỗi thời gian (time-series model)
    :::

-   Nhiễu trắng là: một thành phần ngẫu nhiên thể hiện cho yếu tố không thể dự báo của model và không có tính qui luật.

[![Hình 4: Stationary and non-stationary series](img/stationary.png){fig-alt="A Complete Tutorial on Time Series Modeling in R" fig-align="center"}](https://www.analyticsvidhya.com/blog/2015/12/complete-tutorial-time-series-modeling/)

### Phân tích ARIMA bằng R:

#### Kiểm tra chuỗi dừng:

Và để thỏa mãn giả định này, cần tính toán các chỉ số trên và đánh giá và điều này khá phức tạp. Trong R, ta có hàm `adf.test()` có thể kiểm tra vấn đề này nhanh hơn.

```{r}
#| warning: false
#| message: false
library(tseries)
adf.test(demand_training)    ## p-value = 0.3779 > 0.05 means this series is not stationary
```

Như vậy, ta thấy chuỗi dữ liệu này không phải chuỗi dừng vì giá trị p = 0.3779 \> 0.05 nghĩa là chấp nhận giả thuyết H0: Chuỗi này là chuỗi không dừng.

Trong time-series analyst, ta sẽ có cách để xử lí chuỗi thành chuỗi dừng. Đó là tính sự khác nhau (*Difference*) giữa giá trị t và giá trị của nó ở quá khứ t-1,t-2,...

Trong R, bạn có thể tính bằng cách:

-   `diff(series, lag = n)`: tính sự khác nhau giữa các thời điểm t và t-n.

-   `log(series)`: chuyển time-series sang dạng log.

Này tùy thuộc vào công thức toán học bạn muốn định nghĩa, miễn sao bạn có thể xác định được chuỗi dừng là đạt.

```{r}
#| warning: false
#| message: false
#| column: screen
#| out-width: 80%
#First we will calculate the different in demand product monthly:
#Check stationary assumption:
test<-lapply(1:3, function(x) {
         a<-diff(demand_training, lag = x)
         adf.test(a)$p.value}
       ) #p<0,05 is accepted

## Second transform it to dataframe object:
test<-data.frame(test)
colnames(test)<-c("Lag 1","Lag 2","Lag 3")

## Finally plot the result:
library(gt)
library(gtExtras)
gt(test) %>% 
  cols_align(
    align = "left",
    columns = "Lag 1"
  ) %>% 
  cols_align(
    align = "center",
    columns = "Lag 2"
  ) %>%
   tab_header(
    title = md("**Checking stationary assumption**"),
    subtitle = glue::glue("Time from {min(month_df$datetime)} to 01-03-2015")) %>%
   tab_source_note(
    source_note = "Alternative hypothesis: stationary") %>% 
  gt_theme_538()
```

Kết quả testing cho thấy chỉ có chuỗi 1 và 2 đạt yêu cầu, chuỗi 3 không phải chuỗi dừng vì p-value = 0.107 \> 0.05.

#### Tính toán giá trị PACF và ACF:

##### Định nghĩa về PACF và ACF:

PACF (*Partial Autocorrelation Function*) và ACF (*Autocorrelation Function*) là 2 công thức tính thuộc **Autocorrelation Analyst** - 1 bước quan trọng trong việc phân tích chuỗi dữ liệu thời gian. Mục tiêu của Autocorrelation analyst là tìm ra các mẫu (*pattern*) giữa nhiều chuỗi thời gian và kiểm tra tính ngẫu nhiên.

##### Thực hành trên R:

Sau khi đã xác định được chuỗi dừng, bước tiếp theo là xác định các tham số (p, d, q) cho mô hình ARIMA.

Trong R có hàm `ggtsdisplay` của package **forecast** sẽ hiển thị cả ACF, PACF và Time series plot của đối tượng mà bạn gán. Còn nếu bạn muốn hiển thị riêng giá trị ACF hoặc PACF thì dùng hàm `Acf` hoặc `Pacf` để tính và dùng hàm `autoplot()` để hiển thị biểu đồ.

```{r}
#| warning: false
#| message: false
#| layout-ncol: 2

#Rename of two time series:
ts1<-diff(demand_training, lag = 1)
ts2<-diff(demand_training, lag = 2)
#Plot value ACF for 2 series:
library(forecast)
ggtsdisplay(ts1,
            main = "Time series lag 1",
            theme=theme_bw())
ggtsdisplay(ts2,
            main = "Time series lag 2",
            theme=theme_bw())
```

Dựa vào tricks từ [@tavishsrivastava2023], ta sẽ dựa vào giá trị PACF để xác định bậc của AR và ACF để xác định bậc của MA.

Ví dụ ở trên, đối với chuỗi lag 1, giá trị PACF có sự đứt gãy (*cut off*) ở bậc 2 đến bậc 3 nên có thể thuộc AR(3). Còn giá trị ACF thì có thể thuộc MA(2) hoặc rõ ràng hơn là MA(3). Còn lại, đối với chuỗi lag 2, các bạn có thể làm tương tự.

Vậy mô hình tự chọn cuối cùng là ARIMA(3,0,2).

#### Lựa chọn mô hình tốt nhất:

Thực tế, trong R có hàm `auto.arima`để chúng ta lựa chọn và so sánh nhiều mô hình ARIMA một cách tự động và không nặng về code như dưới đây. Nó sẽ tự liệt kê ra các mô hình phù hợp và chọn ra mô hình tốt nhất.

Ngoài ra, nếu bạn muốn tìm hiểu sâu về cách xây dựng mô hình ARIMA, bạn có thể tham khảo thêm bài blog [@dung]. Anh Chí Dũng có khá nhiều bài viết hay về cách sử dụng R trong nghiên cứu và phân tích kinh tế, bạn có thể tham khảo trang blog của ảnh thông qua đường link [chidungkt](https://rpubs.com/chidungkt/).

```{r}
#| warning: false
#| message: false
#Select the best model:
model<-auto.arima(ts1,trace = T)
```

#### So sánh giá trị dự đoán từ training data với testing data:

Sau khi đã xây dựng mô hình, ta sẽ dùng nó để dự đoán và so sánh với dữ liệu thực tế từ bộ dữ liệu testing data.

```{r}
#| warning: false
#| message: false
#Forecast by training model:
training_forecast<-forecast(model,h = 21)
```

Bảng trình bày các giá trị dự đoán theo từng tháng. Ta thấy chỉ có 4/21 thời điểm mà giá trị thực tế vượt ra giá trị dự đoán trong khoảng tin cậy 80%. Còn đối với giá trị dự đoán trong khoảng tin cậy 95% thì đều đạt yêu cầu.

```{r}
#| warning: false
#| message: false
#Calculate RMSE:
actual<- diff(demand_testing,1)

accuracy<-data_frame(Period = paste(month(testing_df$datetime),
                                    year(testing_df$datetime),
                                    sep = "/")[-1],
                     Actual = actual %>% as.vector(), 
                     High.80 = training_forecast$upper[,1],
                     Low.80 = training_forecast$lower[,1],
                     High.95 = training_forecast$upper[,2],
                     Low.95 = training_forecast$lower[,2]) %>% 
  mutate(Check.80 = ifelse(Actual <= High.80 & Actual >= Low.80,"Pass","Fail"),
         Check.95 = ifelse(Actual <= High.95 & Actual >= Low.95,"Pass","Fail"))

## Finally plot the result
gt(accuracy) %>% 
   tab_header(
    title = md("**Comparing the accuracy of forecasting**"),
    subtitle = glue::glue("Forecasting from {min(testing_df$datetime)} to {max(testing_df$datetime)}")) %>%
   tab_source_note(
    source_note = str_glue("Method: Model {training_forecast$method}")) %>% 
  gt_theme_538() %>% 
   data_color(
    columns = Check.80,
    method = "factor",
    palette = c("red","darkgreen")
  ) %>% data_color(
    columns = Check.95,
    method = "factor",
    palette = c("darkgreen","red")
  ) 
```

Và dưới đây là biểu đồ hiển thị giá trị trung bình (*đường màu xanh dương*), giá trị dự đoán trong khoảng tin cậy 80% (*đường màu xám đậm*) và khoảng tin cậy 95% (*đường màu xám nhạt*).

Ngoài ra ta cũng tính các chỉ số MAE và RMSE của mô hình như sau:

```{r}
## Calculating MAE metric:
sum = 0
for (i in 1:nrow(accuracy)){ 
  sum = abs(accuracy$Actual[i]-training_forecast$mean[i]) + sum
} 

MAE = sum/nrow(accuracy) 

## Calculating RMSE metric:
RMSE= sqrt(mean((accuracy$Actual - training_forecast$mean)^2))
```

```{r}
#| warning: false
#| message: false
#Use chart for presenting the differents:
plot(training_forecast,
      main = str_glue("Method: Model {training_forecast$method}"),
      xlab = "Time",
      ylab = "Order Demand")
lines(actual, 
      col = "red",
      lwd = "2")
legend("topleft",
       legend = c("Actual","Forecast"),
       col = c("red","blue"),
       box.lty = 0,
       lty = 1,
       cex = 1,
       lwd = 2)
```

Ta thấy kết quả dự đoán cũng ổn nhưng vẫn chưa bám sát thực tế. Vì vậy tiếp theo chúng ta sẽ làm cho mô hình tốt hơn ở trang sau [Mô hình SARIMA](SARIMA.qmd)


